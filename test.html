<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MLB Line Movement Report</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 font-sans">
    <div class="container mx-auto p-4">
        <h1 class="text-3xl font-bold text-center mb-6">MLB Line Movement Report</h1>
        <div class="flex justify-center mb-6">
            <button id="fetchDataBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                Fetch MLB Data
            </button>
        </div>
        <div id="loading" class="hidden text-center text-gray-600">Loading...</div>
        <div id="error" class="hidden text-center text-red-600"></div>
        <div id="reportContainer" class="space-y-6"></div>
    </div>

    <script>
        // Helper Functions
        async function fetchJson(url, retries = 2) {
            const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
            const headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36",
                "Accept": "application/json, text/javascript, */*; q=0.01",
                "Referer": "https://www.actionnetwork.com",
                "Origin": "https://www.actionnetwork.com",
            };

            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    const response = await fetch(proxyUrl + url, { headers });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    if (attempt === retries) throw error;
                    await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
                }
            }
        }

        function extractOutcomes(obj, outcomes = []) {
            if (typeof obj === 'object' && obj !== null) {
                if ('outcome_id' in obj) {
                    outcomes.push(obj);
                } else {
                    for (const value of Object.values(obj)) {
                        extractOutcomes(value, outcomes);
                    }
                }
            } else if (Array.isArray(obj)) {
                for (const item of obj) {
                    extractOutcomes(item, outcomes);
                }
            }
            return outcomes;
        }

        function buildEventLookup(obj, eventLookup = {}) {
            if (typeof obj === 'object' && obj !== null) {
                if (Array.isArray(obj)) {
                    for (const item of obj) {
                        buildEventLookup(item, eventLookup);
                    }
                } else {
                    if ('id' in obj && 'home_team_id' in obj && 'away_team_id' in obj && 'teams' in obj) {
                        const home = obj.teams.find(t => t.id === obj.home_team_id);
                        const away = obj.teams.find(t => t.id === obj.away_team_id);
                        if (home && away) {
                            eventLookup[obj.id] = {
                                home_team: home.full_name,
                                away_team: away.full_name
                            };
                        }
                    }
                    for (const value of Object.values(obj)) {
                        buildEventLookup(value, eventLookup);
                    }
                }
            }
            return eventLookup;
        }

        function formatOdds(odds) {
            return odds > 0 ? `+${odds.toFixed(1)}` : odds.toFixed(1);
        }

        function detectReverseLineMovement(openOdds, consensusOdds, ticketsPercent, side) {
            const move = consensusOdds - openOdds;
            if (side === 'fade' && move < 0) {
                return { detected: true, type: 'fade_side_became_less_favorable', strength: ticketsPercent };
            }
            return { detected: false, type: null, strength: 0 };
        }

        function generateReport(data, eventLookup) {
            const spreadData = data.filter(item => item.market_type === 'spread');
            if (!spreadData.length) {
                return ['<p>No spread market data found.</p>'];
            }

            const reportLines = [];
            const groupedByEvent = {};
            spreadData.forEach(item => {
                if (!groupedByEvent[item.event_id]) {
                    groupedByEvent[item.event_id] = [];
                }
                groupedByEvent[item.event_id].push(item);
            });

            for (const [eventId, eventData] of Object.entries(groupedByEvent)) {
                const homeTeam = eventLookup[eventId]?.home_team || 'Unknown';
                const awayTeam = eventLookup[eventId]?.away_team || 'Unknown';

                const openData = eventData.filter(d => d.book_id === 'Open');
                const consensusData = eventData.filter(d => d.book_id === 'Consensus');
                const sportsbookData = eventData.filter(d => !['Open', 'Consensus'].includes(d.book_id));

                if (!openData.length || !consensusData.length) continue;

                reportLines.push(`<div class="bg-white shadow-md rounded-lg p-6"><h2 class="text-xl font-semibold">${homeTeam} vs ${awayTeam} - SPREAD</h2>`);
                reportLines.push('<hr class="my-2">');

                const homeSide = consensusData.find(d => d.side.toLowerCase().includes('home'));
                const awaySide = consensusData.find(d => d.side.toLowerCase().includes('away'));

                if (!homeSide || !awaySide) continue;

                const homeTickets = homeSide.tickets_percent || 0;
                const homeMoney = homeSide.money_percent || 0;
                const awayTickets = awaySide.tickets_percent || 0;
                const awayMoney = awaySide.money_percent || 0;

                let publicSide, publicTickets, publicMoney, fadeSide, fadeTickets, fadeMoney, publicValue, fadeValue;
                if (homeTickets > awayTickets) {
                    publicSide = 'home';
                    publicTickets = homeTickets;
                    publicMoney = homeMoney;
                    fadeSide = 'away';
                    fadeTickets = awayTickets;
                    fadeMoney = awayMoney;
                    publicValue = homeSide.value;
                    fadeValue = awaySide.value;
                } else {
                    publicSide = 'away';
                    publicTickets = awayTickets;
                    publicMoney = awayMoney;
                    fadeSide = 'home';
                    fadeTickets = homeTickets;
                    fadeMoney = homeMoney;
                    publicValue = awaySide.value;
                    fadeValue = homeSide.value;
                }

                reportLines.push(`<p><strong>PUBLIC SIDE:</strong> ${publicSide}_${publicValue.toFixed(1)} (${publicTickets.toFixed(0)}% tickets, ${publicMoney.toFixed(0)}% money)</p>`);
                reportLines.push(`<p><strong>FADE SIDE:</strong> ${fadeSide}_${fadeValue.toFixed(1)} (${fadeTickets.toFixed(0)}% tickets, ${fadeMoney.toFixed(0)}% money)</p>`);

                const homeOpen = openData.find(d => d.side.toLowerCase().includes('home'));
                const homeConsensus = consensusData.find(d => d.side.toLowerCase().includes('home'));
                const awayOpen = openData.find(d => d.side.toLowerCase().includes('away'));
                const awayConsensus = consensusData.find(d => d.side.toLowerCase().includes('away'));

                if (!homeOpen || !homeConsensus || !awayOpen || !awayConsensus) continue;

                const homeMove = homeConsensus.odds - homeOpen.odds;
                const awayMove = awayConsensus.odds - awayOpen.odds;

                const homeFavor = homeMove > 0 ? 'LESS favorable' : homeMove < 0 ? 'MORE favorable' : 'NO change';
                const awayFavor = awayMove < 0 ? 'LESS favorable' : awayMove > 0 ? 'MORE favorable' : 'NO change';

                reportLines.push('<p><strong>Line Movements:</strong></p>');
                reportLines.push(`<p>${publicSide}_${publicValue.toFixed(1)}: ${formatOdds(homeMove)} (${homeFavor})</p>`);
                reportLines.push(`<p>${fadeSide}_${fadeValue.toFixed(1)}: ${formatOdds(awayMove)} (${awayFavor})</p>`);

                const rlm = fadeSide === 'away' 
                    ? detectReverseLineMovement(awayOpen.odds, awayConsensus.odds, publicTickets, 'fade')
                    : detectReverseLineMovement(homeOpen.odds, homeConsensus.odds, publicTickets, 'fade');

                if (rlm.detected) {
                    reportLines.push(`<p class="text-red-600 font-bold">ðŸš¨ REVERSE LINE MOVEMENT!</p>`);
                    reportLines.push(`<p>Type: ${rlm.type}</p>`);
                    reportLines.push(`<p>Strength: ${rlm.strength.toFixed(1)}%</p>`);
                }

                reportLines.push('<p><strong>Detailed Analysis:</strong></p>');
                reportLines.push(`<p>${fadeSide}_${fadeValue.toFixed(1)}: ${formatOdds(awayOpen.odds)} â†’ ${formatOdds(awayConsensus.odds)} (Move: ${formatOdds(awayMove)})</p>`);
                reportLines.push(`<p>${publicSide}_${publicValue.toFixed(1)}: ${formatOdds(homeOpen.odds)} â†’ ${formatOdds(homeConsensus.odds)} (Move: ${formatOdds(homeMove)})</p>`);

                for (const side of ['home', 'away']) {
                    const sideData = sportsbookData.filter(d => d.side.toLowerCase().includes(side));
                    if (sideData.length) {
                        const bestOddsRow = sideData.reduce((max, d) => d.odds > max.odds ? d : max, sideData[0]);
                        reportLines.push(`<p>(${bestOddsRow.book_id} spread ${side} ${formatOdds(bestOddsRow.odds)})</p>`);
                    }
                }

                reportLines.push('</div>');
            }

            return reportLines;
        }

        // Main Execution
        async function main() {
            const marketsUrl = "https://www.actionnetwork.com/_next/data/_Owd9Pe9zClPGo9ZBiBYQ/mlb/sharp-report.json?league=mlb";
            const gamesUrl = "https://www.actionnetwork.com/_next/data/_Owd9Pe9zClPGo9ZBiBYQ/public-betting.json";

            const loading = document.getElementById('loading');
            const errorDiv = document.getElementById('error');
            const reportContainer = document.getElementById('reportContainer');
            loading.classList.remove('hidden');
            errorDiv.classList.add('hidden');
            reportContainer.innerHTML = '';

            try {
                // Fetch data
                const [marketsData, eventsData] = await Promise.all([
                    fetchJson(marketsUrl),
                    fetchJson(gamesUrl)
                ]);

                // Extract outcomes and event lookup
                const outcomes = extractOutcomes(marketsData);
                const eventLookup = buildEventLookup(eventsData);

                // Map book IDs to display names
                const allBooks = marketsData.pageProps?.allBooks || {};
                const idToName = Object.fromEntries(
                    Object.entries(allBooks).map(([id, book]) => [book.id, book.display_name])
                );

                // Prepare data array
                const data = outcomes.map(outcome => {
                    const eventId = outcome.event_id;
                    const tickets = outcome.bet_info?.tickets || {};
                    const money = outcome.bet_info?.money || {};
                    return {
                        event_id: eventId,
                        home_team: eventLookup[eventId]?.home_team || '',
                        away_team: eventLookup[eventId]?.away_team || '',
                        book_id: idToName[outcome.book_id] || outcome.book_id || '',
                        market_type: outcome.type || '',
                        outcome_id: outcome.outcome_id || '',
                        side: outcome.side || '',
                        odds: outcome.odds || 0,
                        value: outcome.value || 0,
                        tickets_percent: tickets.percent || 0,
                        money_percent: money.percent || 0
                    };
                });

                // Filter for Consensus, Open, and top odds
                const consensusData = data.filter(d => d.book_id.includes('Consensus'));
                const openData = data.filter(d => d.book_id.includes('Open'));
                const groupedData = {};
                data.filter(d => !d.book_id.includes('Consensus') && !d.book_id.includes('Open'))
                    .forEach(d => {
                        const key = `${d.event_id}_${d.market_type}_${d.side}`;
                        if (!groupedData[key]) groupedData[key] = [];
                        groupedData[key].push(d);
                    });

                const topOddsData = Object.values(groupedData).map(group => 
                    group.reduce((max, d) => d.odds > max.odds ? d : max, group[0])
                );

                const combinedData = [...consensusData, ...openData, ...topOddsData]
                    .sort((a, b) => a.event_id.localeCompare(b.event_id));

                // Generate and display report
                const reportLines = generateReport(combinedData, eventLookup);
                reportContainer.innerHTML = reportLines.join('');
            } catch (error) {
                errorDiv.classList.remove('hidden');
                errorDiv.innerHTML = `Error: ${error.message}. Please try again.`;
            } finally {
                loading.classList.add('hidden');
            }
        }

        // Event Listener
        document.getElementById('fetchDataBtn').addEventListener('click', main);
    </script>
</body>
</html>
